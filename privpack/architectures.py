"""
Generative adversarial networks to release Binary and Gaussian data,
this module defines the following classes:

- `PrivacyPreservingGAN`

Exception classes:

Functions:


How to use this module
======================
(See the individual classes, methods and attributes for more details)

1. Import .... TODO

2. Define a instance .... TODO

"""

import time

import copy
import abc

import torch
from torch.utils.data import DataLoader

class GenerativeAdversarialNetwork(abc.ABC):

    """
    A Generative Adversarial Network defined using the PyTorch library.

    This abstract class expects one to implement an update adversary method as well
    as an update privatizer method. The naming is according to the goal of this library; release
    privatized data optimized in accordance to a privacy-utility trade-off.
    """

    def __init__(self, device, Validator):
        """
        Initialize a `GenerativeAdversarialNetwork` object.

        Parameters:

        - `device`: the device to be used: CPU or CUDA.
        - `Validator`: The Validator class used to evaluate the current state of the network.
        """
        self.lr = 1e-2
        self.device = device
        self.Validator = Validator

    def set_device(self, device):
        """
        Change the device used by this network.

        Parameters:

        - `device`: the device to be used: CPU or CUDA
        """
        self.device = device

    def get_device(self):
        """Get the device this network is currently using."""
        return self.device

    def get_privatizer(self):
        """Get a deep copy of the privatizer network that belongs to this network."""
        return copy.deepcopy(self.privatizer)

    def get_adversary(self):
        """Get a deep copy of the adversary network that belongs to this network."""
        return copy.deepcopy(self.adversary)

    @abc.abstractmethod
    def _update_adversary(self, entry, x_batch):
        """
        Abstract method called during training of the network to update the adversary.
        """
        pass

    @abc.abstractmethod
    def _update_privatizer(self, entry, x_batch, y_batch, lambd, delta):
        """
        Abstract method called during training of the network to update the privatizer.
        """
        pass

    def train(self, train_data, test_data, epochs, delta,
              lambd=500, batch_size=1, 
              privatizer_train_every_n=1, 
              adversary_train_every_n=1,
              data_sampler=None, k=1):
        
        """
        Train the Generative Adversarial Network using the implemented privatizer and adversary network.
        The privatizer network and adversary network are both trained using the supplied `train_data`. However,
        the privatizer network is trained every nth batch-iteration supported by the `privatizer_train_every_n` parameter.
        Identically, the adversary network is trained only every nth batch-iteration supported by the `adversary_train_every_n`.
        Where both should be divisible by 5 due to the current logging system.

        Parameters:

        - `train_data`: the training data used for training the generative adversarial network.
        - `test_data`: the testing data used for printing validation results on the generative adversarial network.
        - `lambd`: Lambda defines the penalty strength for the utility measure.
        - `batch_size`: The batch size used when training with the supplied `train_data`.
        - `privatizer_train_every_n`: Parameter defining when to update the privatizer network; Default=1.
        - `adversary_train_every_n`: Parameter defining when to update the adversary network; Default=1.
        - `data_sampler`: Function used for generating samples by the privatizer network.
        - `k`: The number of samples which should be generated by the supplied data_sampler function.

        """

        # For logging reasons only....
        if privatizer_train_every_n != 1 and privatizer_train_every_n % 5 != 0:
            raise Exception('Privatizer is constrained to be trained every or every fifth loop, but is trained every {} loop'.format(
                privatizer_train_every_n))

        if adversary_train_every_n != 1 and adversary_train_every_n % 5 != 0:
            raise Exception('Adversary is constrained to be trained every or every fifth loop, but is trained every {} loop'.format(
                privatizer_train_every_n))

        print('Using device:', self.device)
        print()

        start = time.time()

        adversary_loss = 0
        privatizer_loss = 0

        loader = DataLoader(train_data, batch_size=batch_size)
        for epoch in range(epochs):

            # Additional Info when using cuda
            if self.device.type == 'cuda':
                print(torch.cuda.get_device_name(0))
                print('Memory Usage:')
                print('Allocated:', round(
                    torch.cuda.memory_allocated(0) / 1024 ** 3, 1), 'GB')
                print('Cached:   ', round(
                    torch.cuda.memory_cached(0) / 1024 ** 3, 1), 'GB')
                print()

            self.adversary.train()
            self.privatizer.train()

            for i, sample in enumerate(loader):
                x_batch = sample[:, :self.privacy_size].to(self.device)
                y_batch = sample[:, self.privacy_size:].to(self.device)
                sample = sample.to(self.device)

                self.adversary_optimizer.zero_grad()
                self.privatizer_optimizer.zero_grad()

                if data_sampler is not None:
                    self.sampled_data = data_sampler(sample, k)

                if i % adversary_train_every_n == 0:
                    adversary_loss = self._update_adversary(sample, x_batch)

                # Update privatizer
                if i % privatizer_train_every_n == 0:
                    (privatized, privatizer_loss) = self._update_privatizer(
                        sample, x_batch, y_batch, lambd, delta)

                # Elapsed time
                elapsed = time.time() - start  # Keep track of how much time has elapsed

                if i % 500 == 0:
                    network_statistics = self.Validator.compute_network_statistics(
                        self, train_data, test_data, noise_size=self.n_noise, privacy_dim=self.privacy_size)
                    print('epoch: {}, time: {:.3f}s, Adversary loss: {:.3f}, Privatizer loss: {:.3f}'.format(
                        epoch, elapsed, adversary_loss.item(), privatizer_loss.item()))
                    print('{}'.format(network_statistics))
